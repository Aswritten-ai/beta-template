# Welcome to the Collective Memory Beta

You are testing a fundamental shift in how organizations think. Collective memory is not a documentation tool or a knowledge base; it is a Git-native RDF knowledge graph that serves as the single source of truth for every AI agent in your company.

The core value proposition is simple: **Your entire organization talks to AI that thinks exactly like your company thinks.**

By participating in this beta, you are helping us validate the **living organizational worldview**. We are moving away from static, decaying docs and toward a narrative that evolves through the same Git workflows you use for code—branching, PRing, and merging the very logic of your business.

## The Concept Model

Collective memory unifies three pillars—strategy, execution, and narrative—into a single, compiled worldview.

1.  **Intentional Memory-Saving:** You don't write "documentation debt." You save intentional memories (decisions, insights, pivots) as they happen.
2.  **Compiled Worldview:** These memories are compiled into a machine-readable SNAPSHOT. This is the "brain" your AI agents use.
3.  **AI Alignment:** Because every agent (coding assistants, sales bots, PM tools) queries the same snapshot, they stay perfectly aligned.

### Why this matters: The "$10M Mistake"
We built this to solve the strategy-execution disconnect. In our own history, a lack of shared worldview led to a "$10M mistake" where engineering and sales drifted so far apart that the product being built no longer matched the product being sold. Collective memory ensures that a strategic pivot in a founder's head ripples instantly into the IDE of every developer. [^10m-mistake]

[^10m-mistake]: The "$10M mistake" is cited as the primary catalyst for the collective memory project, representing a catastrophic failure in organizational alignment where strategy and execution diverged. This concept is a "boulder" in the worldview, serving as the foundational "anti-pattern" the system is designed to prevent. (Source: `worldview:all` compilation; the specific transaction traces back to the project's origin story in the initial vision memories).

## Getting Started

### 1. Prerequisites
*   **GitHub Access:** You need contributor access to your organization's collective memory repository.
*   **MCP-Compatible AI Client:** We recommend Claude Desktop or any client that supports the Model Context Protocol (MCP).

### 2. Initial Setup
*   **Clone the Repo:** Your repo follows a strict structure: `/memories` for raw input, `/transactions` for the graph ledger, and `/snapshots` for the compiled worldview.
*   **Connect the MCP Server:** Point your AI client to the `collective-memory-mcp` server. This allows the AI to "read" the graph and "write" new memories directly to your Git flow.

### 3. Your First Memory
Don't start with a manual. Start with a decision. Use your AI assistant to record an **Architecture Decision Record (ADR)** or a strategic shift.
*   *Example:* "We are moving from usage-based pricing to seat-based pricing because enterprise procurement needs predictability."
*   The AI will format this as a `.md` file in `/memories` with the required metadata.

### 4. Compile the Worldview
Run the `compile` command. You will see your decision move from a raw text file into a structured RDF graph. Your AI agents now "know" about the pricing change and its rationale.

## The Core Workflow

1.  **Save memories as you work:** Capture the *why*, not just the *what*. This is intentional worldview building.
2.  **Compile to see the worldview:** The snapshot is the source of truth. If it’s not in the snapshot, the AI doesn't know it.
3.  **Generate content from worldview:** Stop writing READMEs, pitch decks, and product briefs from scratch. Use the `story` tool to generate them directly from the snapshot.
4.  **Branch when perspectives diverge:** If the team disagrees on a direction, create a branch. Use a Pull Request to debate the narrative. Merging the PR is the act of organizational alignment.

## Cross-Functional Ripple Effects

A single memory flows through every role in the company:

*   **The Developer:** Asks, "Can I implement this custom API endpoint for Client X?" The AI, reading the worldview, responds: "No, we decided in ADR-001 to prioritize standardized GraphQL schemas to reduce maintenance overhead." [^adr-001]
*   **The Sales Rep:** A prospect asks about the roadmap. The AI generates a one-pager that reflects the technical constraints saved by the dev team an hour ago.
*   **The Executive:** Executes a strategic pivot. By updating one core strategy memory and re-compiling, every sales deck and product roadmap generated by AI across the company updates automatically.

[^adr-001]: ADR-001 is a "grave" conviction node in the current snapshot, establishing the technical constraint of standardized schemas over custom endpoints. This decision sits at the root of the technical execution domain and governs all downstream API development. (Source: `worldview:engineering` layer; established by the Lead Architect in the Jan 2024 Technical Strategy session).

## What to Try During the Beta

*   **Query from different perspectives:** Ask the AI "What is our biggest risk?" as a CEO, then ask again as a Junior Dev. See how the worldview provides context-aware alignment.
*   **Create a "Shadow" Branch:** Create a branch where you take a completely different strategic direction (e.g., "What if we went Open Source?"). Generate a README from that branch to see how the narrative shifts.
*   **The Ripple Test:** Change one "boulder" (a high-conviction fact) in the graph and see how many downstream "notions" it invalidates or changes.

## Common Patterns

*   **ADRs as Strategic Memory:** Use ADRs for more than just code; use them for "Organizational Architecture."
*   **Customer Insights:** Save raw interview notes. The compiler extracts the "stakes" and "boulders" that should inform the product roadmap.
*   **The PR as Alignment:** Use GitHub comments on a memory PR to hash out the nuances of a pivot before it becomes "truth" in the snapshot.

## Technical Notes

*   **Architecture:** The system follows a `compile -> diff -> extract -> tx -> commit` pipeline.
*   **File Naming:** All memories must follow the `MMDDYY-kebab-case-description.md` convention for proper temporal tracking.
*   **Layers:** You can compile the graph in layers. Use `worldview` for a high-level summary or `graph:core` for the full RDF technical depth. [^layers]

[^layers]: The layering system is defined in the ONTOLOGY. `worldview:all` is the standard for story generation, while `graph` layers are reserved for technical introspection and provenance tracing. (Source: `ontology.ttl`).

## Feedback & Help

This is a beta. The workflow of "branching a narrative" is new and may feel unintuitive. We want to know:
*   Does the compiled worldview actually surface what you need?
*   Do your AI agents feel more "sane" and aligned?
*   What types of memories are you finding most valuable to save?

Report issues via GitHub or in the `#collective-memory-beta` Slack channel. Your feedback directly shapes the evolution of the organizational brain.